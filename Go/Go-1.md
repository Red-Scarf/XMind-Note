# 结构
```go
package main
import "fmt"
func main() {
   /* 这是我的第一个简单的程序 */
   fmt.Println("Hello, World!")
}
```
1. 第一行代码 package main 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
2. 下一行 import "fmt" 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。
3. 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。
4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。
5. 下一行 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。
使用 fmt.Print("hello, world\n") 可以得到相同的结果。
Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。
6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。
7. `{` 不能单独放在一行
8. 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。
9. 文件夹名与包名没有直接关系，并非需要一致，`但最好一致`
10. 同一个文件夹下的文件只能有一个包名，否则编译报错。

# 语法
一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 `;` 结尾，因为这些工作都将由 Go 编译器自动完成。

如果将多个语句写在同一行，它们则必须使用 `;` 人为区分，但在实际开发中并不鼓励这种做法。

标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。

Go 语言的字符串可以通过 `+` 实现

### 关键字
Go 代码中会使用到的 25 个关键字或保留字：
|   |   |   |   |   |
| --- | --- | --- | --- | --- |
| break | default | func | interface | select |
| case | defer | go | map | struct |
| chan | else | goto | package | switch |
| const | fallthrough | if | range | type |
| continue | for | import | return | var |

### 标识符
Go 语言还有 36 个预定义标识符：
|   |   |   |   |   |   |   |   |   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| append | bool | byte | cap | close | complex | complex64 | complex128 | uint16 |
| copy | false | float32 | float64 | imag | int | int8 | int16 | uint32 |
| int32 | int64 | iota | len | make | new | nil | panic | uint64 |
| print | println | real | recover | string | true | uint | uint8 | uintptr |

# 数据类型
## 1. 布尔型
布尔型的值只可以是常量 true 或者 false。

## 2. 数字型
整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。
1. uint8, 无符号 8 位整型 (0 到 255)
2. uint16, 无符号 16 位整型 (0 到 65535)
3. uint32, 无符号 32 位整型 (0 到 4294967295)
4. uint64, 无符号 64 位整型 (0 到 18446744073709551615)
5. uint64, 无符号 64 位整型 (0 到 18446744073709551615)
6. int16, 有符号 16 位整型 (-32768 到 32767)
7. int32, 有符号 32 位整型 (-2147483648 到 2147483647)
8. int64, 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)
9. float32, IEEE-754 32位浮点型数
10. float64, IEEE-754 64位浮点型数
11. complex64, 32 位实数和虚数
12. complex128, 64 位实数和虚数
13. byte, 类似 uint8
14. rune, 类似 int32
15. uint, 32 或 64 位
16. int, 与 uint 一样大小
17. uintptr, 无符号整型，用于存放一个指针
## 3. 字符串
字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。

## 4. 派生类
* (a) 指针类型(Pointer)
* (b) 数组类型
* (c) 结构化类型(struct)
* (d) Channel 类型
* (e) 函数类型
* (f) 切片类型
* (g) 接口类型(interface)
* (h) Map 类型

# 变量
使用 `var` 声明变量，变量名由字母、数字、下划线组成，其中首个字符不能为数字。
变量声明时，需要指定变量的类型，或者直接给变量赋值。

## 变量的初始值
* 数值类型（包括complex64/128）为 0
* 布尔类型为 false
* 字符串为 ""（空字符串）
* 以下几种类型为 nil：
```go
var a *int
var a []int
var a map[string] int
var a chan int
var a func(string) int
var a error // error 是接口
```

可以使用 `:=` 声明变量并赋值，如果 `:=` 左侧没有新的变量，会产生编译错误
```go
var intVal int
intVal :=1 // 编译错误
intVal, intVal1 := 1 // 左侧存在新的变量
```
不带声明格式的变量只能在函数体中出现
```go
var ( // 这种因式分解关键字的写法一般用于声明全局变量
    a int
    b bool
)
```

## 值类型和引用类型
所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值，当使用等号 = 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝。

可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置（句柄/数组头）。

引用变量的内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 `r2 = r1` 时，只有引用（地址）被复制。

## 注意
不能重复声明同名变量，以下用法错误
```go
var a string = "asdsda"
var a string = "1231" // 错误
a := "89789" // 错误
```

单纯声明变量却不使用，也会产生编译报错。**全局变量是允许声明但不使用的**。

多变量可以在同一行进行赋值
```go
var a, b int
var c string
a, b, c = 5, 7, "abc"
```
利用该特性，可以实现变量的值交换
```go
var a, b, c = 1, 2, 3
a, b, c = b, c, a // 2, 3, 1
```

空白标识符 `_` (下划线) 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃。

`_` 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你**必须使用所有被声明的变量**，但有时你并不需要使用从一个函数得到的所有返回值。

并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：`val, err = Func1(var1)`。

# 常量
常量是一个简单值的标识符，在程序运行时，不会被修改的量。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。
```go
// 可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
const identifier [type] = value
```

常量还可以用作枚举：
```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```
常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过。

## iota
特殊常量，可以认为是一个可以被编译器修改的常量。

iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。

> 常量枚举时，如果没有给变量赋值，变量自动使用上一行的等式。
```go
const (
    a = iota
    b = iota
    c = iota
)
// 等价于
const (
    a = iota
    b
    c
)
// ================
const (
    i = 1 << iota
    j = 3 << iota
    k
    l
)
// 等价于
const (
    i = 1 << iota
    j = 3 << iota
    k = 3 << iota
    l = 3 << iota
)
```

iota实际用法
```go
package main
import "fmt"
func main() {
    const (
            a = iota   //0
            b          //1
            c          //2
            d = "ha"   //独立值，iota += 1
            e          //"ha"   iota += 1
            f = 100    //iota +=1
            g          //100  iota +=1
            h = iota   //7,恢复计数
            i          //8
    )
    fmt.Println(a,b,c,d,e,f,g,h,i)
}
```