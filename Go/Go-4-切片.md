# 切片
## 概念
Go 语言切片是对数组的抽象。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

切片(slice)是对数组一个连续片段的引用(该数组我们称之为相关数组，通常是匿名的)，所以切片是一个引用类型(因此更类似于 C/C++ 中的数组类型)。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。

## 切片细则
切片是可索引的，并且可以由 len() 函数获取长度。

给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度:切片是一个 长度可变的数组。

切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。

切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少:它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片， cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于切片 s 来说该不等式永远成立: 0 <= len(s) <= cap(s) 。

多个切片如果表示同一个数组的片段，它们可以共享数据;因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。

> 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。

```go
var sli []int
fmt.Println(sli) // []
fmt.Println(len(sli)) // 0
fmt.Println(cap(sli)) // 0
fmt.Println(sli == nil) // true
```
## 初始化切片
make方式创建切片，对应用类型的数据都可以使用make函数创建,该函数会返回该类型的引用。
```go
// 类型为[]int,长度为10，容量为20
slice := make([]int, 10, 20)
// 直接指定字面量
slice := []int{1,2,3,4,5}
```
不指定切片的容量，例如`slice := make([]int, 10)`，那么该切片的容量和长度相等。

因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。

例子中指定了容量是20，因为切片的长度是10，所以只能访问10个元素，剩下的10个元素，需要切片扩充后才可以访问。

通过字面量创建切片和创建数组的方式非常像，只不过不用指定[]中的值([]里面没有...)，这时候切片的长度和容量是相等的，并且会根据我们指定的字面量推导出来。当然我们也可以像数组一样，只初始化某个索引的值。
```go
slice := []int{4:1}
```

> 切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。

> nil切片表示不存在的切片，而空切片表示一个空集合。
```go
//nil切片
var slice []int
//空切片
slice:=[]int{}
```

## 基于其他切片/数组创建
切片另外一个用处比较多的创建是基于现有的数组或者切片创建。
```go
// 切片复制
slice := []int{1, 2, 3, 4, 5, 6}
fmt.Println(slice) // [1 2 3 4 5 6]
slice1 := slice[:]
fmt.Println(slice1) // [1 2 3 4 5 6]
slice2 := slice[:4]
fmt.Println(slice2) // [1 2 3 4]
slice3 := slice[1:]
fmt.Println(slice3) // [2 3 4 5 6]
slice4 := slice[2:5]
fmt.Println(slice4) // [3 4 5]
```

基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，她表示以i索引开始，到j索引结束,截取原数组或者切片，创建而成的新切片，新切片的值包含原切片的i索引，但是**不包含j索引**。

i如果省略，默认是0；j如果省略默认是原数组或者切片的长度,所以例子中的三个新切片的值是一样的。

> i和j都不能超过原切片或者数组的索引。

新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变，所以原切片的值也改变了。当然对于基于数组的切片也一样的。

基于原数组或者切片创建一个新的切片后，那么新的切片的大小就是i和j的差值，容量就是数组长度减去切片开头下标的值。

基于一个数组或者切片使用2个索引创建新切片的方法，此外还有一种3个索引的方法，第三个值表示容量所在的下标。
```go
slice := []int{1, 2, 3, 4, 5}
newSlice := slice[1:2:3] // 容量为3-1=2
```

> **绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针**

## 内存结构
切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量。

获取数组首地址需要取地址符(&)，获取切片的地址不要加取地址符。

## 使用切片
切片可以按需增长，使用内置的 `append()` 函数可以为切片追加一个元素。其中如何增加，返回的切片是否还是原切片，长度容量变化，均由函数内部处理。

```go
newSlice=append(newSlice,10)
```
使用append函数时，如果底层数组容量足够，会将相应的数组位置的值改为10。底层数组长度不够，会生成一个新的底层数组。

> 切片容量增长算法：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。

切片支持追加多个元素或一个切片
```go
newSlice=append(newSlice,10,20,30) // 多个元素
newSlice=append(newSlice,slice...) // 追加切片
```

## 迭代
```go
slice := []int{1, 2, 3, 4, 5}
// 如果不需要使用索引， i 可以使用 _ 代替
for i,v:=range slice{
    fmt.Printf("索引:%d,值:%d\n",i,v)
}
// 普通的 for 循环
for i := 0; i < len(slice); i++ {
    fmt.Printf("值:%d\n", slice[i])
}
```

## 切片参数
切片类型作为参数时，因为切片变量存的实际是引用类型，所以函数内部就是直接操作切片的底层数组。

## new()和make()的区别
看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。

* new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址:这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &T{}。
* make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型:切片、map 和 channel

# 字符串，数组，切片
字符串本质是一个字符数组，可以获取字符串的切片。
```go
str := "你好吗"
fmt.Println(str)
strslice := str[:]
fmt.Println(strslice)
```