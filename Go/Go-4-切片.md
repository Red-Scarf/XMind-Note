# 切片
## 概念
Go 语言切片是对数组的抽象。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

切片(slice)是对数组一个连续片段的引用(该数组我们称之为相关数组，通常是匿名的)，所以切片是一个引用类型(因此更类似于 C/C++ 中的数组类型)。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。

## 切片细则
切片是可索引的，并且可以由 len() 函数获取长度。

给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度:切片是一个 长度可变的数组。

切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。

切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少:它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片， cap(s) 就是从 s[0] 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于切片 s 来说该不等式永远成立: 0 <= len(s) <= cap(s) 。

多个切片如果表示同一个数组的片段，它们可以共享数据;因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。

> 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。

```go
var sli []int
fmt.Println(sli) // []
fmt.Println(len(sli)) // 0
fmt.Println(cap(sli)) // 0
fmt.Println(sli == nil) // true
```
## 初始化切片
make方式创建切片，对应用类型的数据都可以使用make函数创建,该函数会返回该类型的引用。
```go
// 类型为[]int,长度为10，容量为20
slice := make([]int, 10, 20)
// 直接指定字面量
slice := []int{1,2,3,4,5}
```
不指定切片的容量，例如`slice := make([]int, 10)`，那么该切片的容量和长度相等。

因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。

例子中指定了容量是20，因为切片的长度是10，所以只能访问10个元素，剩下的10个元素，需要切片扩充后才可以访问。

通过字面量创建切片和创建数组的方式非常像，只不过不用指定[]中的值([]里面没有...)，这时候切片的长度和容量是相等的，并且会根据我们指定的字面量推导出来。当然我们也可以像数组一样，只初始化某个索引的值。
```go
slice := []int{4:1}
```

> 切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。

> nil切片表示不存在的切片，而空切片表示一个空集合。
```go
//nil切片
var slice []int
//空切片
slice:=[]int{}
```

## 基于其他切片/数组创建
切片另外一个用处比较多的创建是基于现有的数组或者切片创建。
```go
slice := []int{1, 2, 3, 4, 5}
slice1 := slice[:]
slice2 := slice[0:]
slice3 := slice[:5]
 
fmt.Println(slice1)
fmt.Println(slice2)
fmt.Println(slice3)
```

基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，她表示以i索引开始，到j索引结束,截取原数组或者切片，创建而成的新切片，新切片的值包含原切片的i索引，但是**不包含j索引**。

i如果省略，默认是0；j如果省略默认是原数组或者切片的长度,所以例子中的三个新切片的值是一样的。

> i和j都不能超过原切片或者数组的索引。